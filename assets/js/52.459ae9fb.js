(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{457:function(t,a,s){"use strict";s.r(a);var n=s(58),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[t._v("#")]),t._v(" 二叉树")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://labuladong.gitee.io/algo/2/20/33/",target:"_blank",rel:"noopener noreferrer"}},[t._v("东哥带你刷二叉树（纲领篇"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("二叉树解题的思维模式分两类")]),t._v(" "),s("ol",[s("li",[t._v("是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。")]),t._v(" "),s("li",[t._v("是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。")])]),t._v(" "),s("blockquote",[s("p",[t._v("如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。")])]),t._v(" "),s("p",[t._v("只要涉及递归，都可以抽象成二叉树的问题")]),t._v(" "),s("h2",{attrs:{id:"深入理解前中后序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深入理解前中后序"}},[t._v("#")]),t._v(" 深入理解前中后序")]),t._v(" "),s("h2",{attrs:{id:"两种解题思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两种解题思路"}},[t._v("#")]),t._v(" 两种解题思路")]),t._v(" "),s("p",[t._v("二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。")]),t._v(" "),s("h3",{attrs:{id:"遇到一道二叉树的题目时的通用思考过程是"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遇到一道二叉树的题目时的通用思考过程是"}},[t._v("#")]),t._v(" 遇到一道二叉树的题目时的通用思考过程是")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现")])]),t._v(" "),s("li",[s("p",[t._v("是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。")])]),t._v(" "),s("li",[s("p",[t._v("无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做")])])]),t._v(" "),s("h2",{attrs:{id:"后序位置的特殊之处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后序位置的特殊之处"}},[t._v("#")]),t._v(" 后序位置的特殊之处")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。")])]),t._v(" "),s("li",[s("p",[t._v("前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了")])]),t._v(" "),s("li",[s("p",[t._v("前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h0ncb741w5j20u012ldix.jpg",alt:""}})]),t._v(" "),s("blockquote",[s("p",[t._v("前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据")])]),t._v(" "),s("p",[t._v("一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了")]),t._v(" "),s("h2",{attrs:{id:"三叉树遍历框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三叉树遍历框架"}},[t._v("#")]),t._v(" 三叉树遍历框架")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 三叉树遍历框架")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("Node node1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Node node2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" node2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**** 前序位置 ****/")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将传入的两个节点穿起来")]),t._v("\n    node1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 连接相同父节点的两个子节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 连接跨越父节点的两个子节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"构造篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造篇"}},[t._v("#")]),t._v(" 构造篇")]),t._v(" "),s("p",[t._v("二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。")])])}),[],!1,null,null,null);a.default=e.exports}}]);