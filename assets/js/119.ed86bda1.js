(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{523:function(t,a,v){"use strict";v.r(a);var r=v(58),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"}},[t._v("「硬核 JS」你真的了解垃圾回收机制吗"),v("OutboundLink")],1),t._v(" "),v("a",{attrs:{href:"https://juejin.cn/post/6844903993051709447",target:"_blank",rel:"noopener noreferrer"}},[t._v("关于 v8 垃圾回收记住，看这篇就够啦 😎"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"什么是垃圾回收机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾回收机制"}},[t._v("#")]),t._v(" 什么是垃圾回收机制？")]),t._v(" "),v("p",[t._v("对于未使用的变量进行清楚")]),t._v(" "),v("h2",{attrs:{id:"垃圾是怎样产生的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾是怎样产生的"}},[t._v("#")]),t._v(" 垃圾是怎样产生的？")]),t._v(" "),v("p",[t._v("失去引用")]),t._v(" "),v("h2",{attrs:{id:"为什么要进行垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要进行垃圾回收"}},[t._v("#")]),t._v(" 为什么要进行垃圾回收？")]),t._v(" "),v("h2",{attrs:{id:"垃圾回收是怎样进行的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收是怎样进行的"}},[t._v("#")]),t._v(" 垃圾回收是怎样进行的？")]),t._v(" "),v("p",[t._v("定期找出那些不再用到的内存（变量），然后释放其内存")]),t._v(" "),v("blockquote",[v("p",[t._v("使用哪一种策略又浏览器决定")])]),t._v(" "),v("h3",{attrs:{id:"标记清除算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[t._v("#")]),t._v(" 标记清除算法")]),t._v(" "),v("ul",[v("li",[t._v("优点：那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0 和 1）就可以为其标记，非常简单")]),t._v(" "),v("li",[t._v("缺点：就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片")])]),t._v(" "),v("p",[t._v("解决：")]),t._v(" "),v("p",[t._v("标记整理（Mark-Compact）算法")]),t._v(" "),v("p",[t._v("只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存")]),t._v(" "),v("h3",{attrs:{id:"引用计数算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[t._v("#")]),t._v(" 引用计数算法")]),t._v(" "),v("p",[t._v("它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收")]),t._v(" "),v("p",[t._v("使用的问题：循环引用")]),t._v(" "),v("p",[t._v("优点： 引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾\n缺点： 1.它需要一个计数器 2.无法解决循环引用无法回收的问题")]),t._v(" "),v("h2",{attrs:{id:"v8-引擎对垃圾回收进行了哪些优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎对垃圾回收进行了哪些优化"}},[t._v("#")]),t._v(" V8 引擎对垃圾回收进行了哪些优化？")]),t._v(" "),v("blockquote",[v("p",[t._v("大多数浏览器都是基于标记清除算法\nV8 中对垃圾回收机制的优化")])]),t._v(" "),v("p",[t._v("分代式垃圾回收")]),t._v(" "),v("p",[t._v("对于 大的老的存活时间长的对象 和 小的新的存活时间短的对象 处理方式应该不一样")]),t._v(" "),v("p",[t._v("新老生代")]),t._v(" "),v("p",[t._v("V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收")]),t._v(" "),v("h3",{attrs:{id:"新生代垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新生代垃圾回收"}},[t._v("#")]),t._v(" 新生代垃圾回收")]),t._v(" "),v("p",[t._v("新生代分成 2 个区 使用区 空闲区")]),t._v(" "),v("p",[t._v("当进行垃圾回收时，V8 将使用区部分的对象检查一遍，如果是存活对象那么复制到空闲区内存中(在空闲区内存中按照顺序从头放置的（节省空间）)，如果是非存活对象直接回收即可。")]),t._v(" "),v("p",[t._v("然后空闲区变成使用区 ，使用区变成空闲区 如此反复")]),t._v(" "),v("h3",{attrs:{id:"老生代垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#老生代垃圾回收"}},[t._v("#")]),t._v(" 老生代垃圾回收")]),t._v(" "),v("ol",[v("li",[t._v("标记清除")]),t._v(" "),v("li",[t._v("内存碎片整理")])]),t._v(" "),v("h4",{attrs:{id:"增量标记"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#增量标记"}},[t._v("#")]),t._v(" 增量标记")]),t._v(" "),v("p",[t._v('一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"歇"一下')])])}),[],!1,null,null,null);a.default=_.exports}}]);