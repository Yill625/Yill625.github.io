(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{511:function(t,e,s){"use strict";s.r(e);var o=s(58),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"深入浅出-nodejs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出-nodejs"}},[t._v("#")]),t._v(" 深入浅出 nodejs")]),t._v(" "),s("h2",{attrs:{id:"commonjs-的模块规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commonjs-的模块规范"}},[t._v("#")]),t._v(" CommonJS 的模块规范")]),t._v(" "),s("ol",[s("li",[t._v("模块的引用")])]),t._v(" "),s("p",[t._v("在 CommonJS 规范中，存在 require()方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("模块的定义")])]),t._v(" "),s("p",[t._v("exports 是 module 的属性 在 Node 中，一个文件就是一个模块")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("模块标识")])]),t._v(" "),s("p",[t._v("模块标识其实就是传递给 require()方法的参数，它必须是符合小驼峰命名的字符串，或者以．、.．开头的相对路径，或者绝对路径")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://tva1.sinaimg.cn/large/008i3skNgy1gy7sizmz2pj31900juwfu.jpg",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"node-分析目录分析和包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-分析目录分析和包"}},[t._v("#")]),t._v(" node 分析目录分析和包")]),t._v(" "),s("p",[t._v("在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将目录当做一个包来处理。在这个过程中，Node 对 CommonJS 包规范进行了一定程度的支持。首先，Node 在当前目录下查找 package.json（CommonJS 包规范定义的包描述文件），通过 JSON.parse()解析出包描述对象，从中取出 main 属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果 main 属性指定的文件名错误，或者压根没有 package.json 文件，Node 会将 index 当做默认文件名，然后依次查找 index.js、index.json、index.node。")])])}),[],!1,null,null,null);e.default=a.exports}}]);