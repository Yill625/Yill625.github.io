(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{453:function(t,n,e){"use strict";e.r(n);var i=e(58),r=Object(i.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"二分搜索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二分搜索"}},[t._v("#")]),t._v(" 二分搜索")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://labuladong.github.io/algo/2/19/26/",target:"_blank",rel:"noopener noreferrer"}},[t._v("我写了首诗，让你闭着眼睛也能写对二分搜索"),e("OutboundLink")],1)]),t._v(" "),e("ol",[e("li",[e("p",[t._v("分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。")])]),t._v(" "),e("li",[e("p",[t._v("注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。")])]),t._v(" "),e("li",[e("p",[t._v("如需定义左闭右开的「搜索区间」搜索左右边界，只要在 nums[mid] == target 时做修改即可，搜索右侧时需要减一。")])]),t._v(" "),e("li",[e("p",[t._v("如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 nums[mid] == target 条件处的代码和返回的逻辑即可")])])]),t._v(" "),e("p",[t._v("二分法模板")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int binary_search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if(nums[mid] == target) {\n            // 直接返回\n            return mid;\n        }\n    }\n    // 直接返回\n    return -1;\n}\n\nint left_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定左侧边界\n            right = mid - 1;\n        }\n    }\n    // 最后要检查 left 越界的情况\n    if (left >= nums.length || nums[left] != target) {\n        return -1;\n    }\n    return left;\n}\n\nint right_bound(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else if (nums[mid] > target) {\n            right = mid - 1;\n        } else if (nums[mid] == target) {\n            // 别返回，锁定右侧边界\n            left = mid + 1;\n        }\n    }\n    // 最后要检查 right 越界的情况\n    if (right < 0 || nums[right] != target) {\n        return -1;\n    }\n    return right;\n}\n\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);