(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{525:function(t,e,r){"use strict";r.r(e);var a=r(58),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"事件循环-event-loop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件循环-event-loop"}},[t._v("#")]),t._v(" 事件循环 Event Loop")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.cn/post/6844903764202094606",target:"_blank",rel:"noopener noreferrer"}},[t._v("一次弄懂 Event Loop"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.bilibili.com/video/BV1K4411D7Jb/?spm_id_from=333.788.b_636f6d6d656e74.7",target:"_blank",rel:"noopener noreferrer"}},[t._v("📺 事件循环原理讲解"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://www.bilibili.com/video/BV1k7411q7rV?from=search&seid=10635364263776804767",target:"_blank",rel:"noopener noreferrer"}},[t._v("📺 2014 年 JS 开发者大会上 philip_roberts 的演讲——What the heck is this event loop anyway?"),r("OutboundLink")],1)])]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/6844904079353708557",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试题：说说事件循环机制(满分答案来了"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/6844903512845860872",target:"_blank",rel:"noopener noreferrer"}},[t._v("这一次，彻底弄懂 JavaScript 执行机制"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),r("p",[t._v("Js 是单线程的 每次只能做一件事 有一些阻塞的事情阻止了页面渲染怎么办 可以类似放到异步里去处理")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://tva1.sinaimg.cn/large/e6c9d24egy1h1szoou8bvj21080hoaar.jpg",alt:""}})]),t._v(" "),r("p",[t._v("一个线程中，事件循环是唯一的，但是任务队列可以拥有多个，任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs")]),t._v(" "),r("p",[t._v("宏任务")]),t._v(" "),r("ul",[r("li",[t._v("script")]),t._v(" "),r("li",[t._v("setTimeout")]),t._v(" "),r("li",[t._v("setInterval")]),t._v(" "),r("li",[t._v("setImmediate")]),t._v(" "),r("li",[t._v("UI render")]),t._v(" "),r("li",[t._v("I/O")])]),t._v(" "),r("p",[t._v("微任务")]),t._v(" "),r("ul",[r("li",[t._v("Promise")]),t._v(" "),r("li",[t._v("MutationObserver(html5 新特性)")]),t._v(" "),r("li",[t._v("Async/Await(实际就是 promise)")])]),t._v(" "),r("h2",{attrs:{id:"async-await-执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async-await-执行顺序"}},[t._v("#")]),t._v(" async/await 执行顺序")]),t._v(" "),r("p",[t._v("旧版 await 后面的流程在最后微任务结束执行")]),t._v(" "),r("p",[t._v("新版变的更快了 如果 await 后面直接跟的为一个变量 种情况的话相当于直接把 await 后面的代码注册为一个微任务\n如果 await 后面跟的是一个异步函数的调用 会跳出 当前执行的异步函数，当所有微任务执行完毕以后，在回到这个函数执行后面的微任务")]),t._v(" "),r("h2",{attrs:{id:"node-和-浏览器-eventloop-的主要区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-和-浏览器-eventloop-的主要区别"}},[t._v("#")]),t._v(" node 和 浏览器 eventLoop 的主要区别")]),t._v(" "),r("p",[t._v("两者最主要的区别在于浏览器中的微任务是在每个相应的宏任务中执行的，而 nodejs 中的微任务是在不同阶段之间执行的")])])}),[],!1,null,null,null);e.default=n.exports}}]);