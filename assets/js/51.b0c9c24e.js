(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{460:function(t,a,e){"use strict";e.r(a);var r=e(58),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"动态规划"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[t._v("#")]),t._v(" 动态规划")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://labuladong.github.io/algo/1/4/",target:"_blank",rel:"noopener noreferrer"}},[t._v("动态规划解题套路框架"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[e("p",[t._v("动态规划问题的一般形式就是求最值")])]),t._v(" "),e("li",[e("p",[t._v("既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举")])]),t._v(" "),e("li",[e("p",[t._v("首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。")])]),t._v(" "),e("li",[e("p",[t._v("动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。")])]),t._v(" "),e("li",[e("p",[t._v("正确的「状态转移方程」")])])]),t._v(" "),e("blockquote",[e("p",[t._v("明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 初始化 base case\ndp[0][0][...] = base\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 求最值(选择1，选择2...)\n")])])]),e("h2",{attrs:{id:"「自顶向下」进行「递归」"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#「自顶向下」进行「递归」"}},[t._v("#")]),t._v(" 「自顶向下」进行「递归」")]),t._v(" "),e("h2",{attrs:{id:"动态规划代码是「自底向上」进行「递推」求解。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态规划代码是「自底向上」进行「递推」求解。"}},[t._v("#")]),t._v(" 动态规划代码是「自底向上」进行「递推」求解。")])])}),[],!1,null,null,null);a.default=s.exports}}]);